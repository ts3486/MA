{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/Tao.S/Desktop/WebDev/MA/frontend/src/Components/Chat/Chat/ChatComponent.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect } from \"react\";\nimport { connect, useSelector } from \"react-redux\";\nimport { io } from \"socket.io-client\"; //Components\n\nimport InfoBar from \"../../Chat/InfoBar/InfoBar\";\nimport Input from \"../../Chat/Input/Input\";\nimport Messages from \"../../Chat/Messages/Messages\";\nimport UserList from \"../../Chat/UserList/UserList\"; //Actions\n// import * as actionTypes_auth from \"../../../store/actions/auth_actions\";\n\nimport \"./Chat_style.css\";\nlet socket;\n\nconst ChatComponent = props => {\n  _s();\n\n  //username of other users. Changes based on selected user.\n  const [username, setUsername] = useState(\"\");\n  const [infoName, setInfoname] = useState(\"\"); //main user\n  // const [username2, setUsername2] = useState(\"Bob\");\n  //room name for each chat \n\n  const [room, setRoom] = useState(\"\");\n  const [message, setMessage] = useState(\"\");\n  const [messages, setMessages] = useState([]); //ENDPOINT is the backend server socket.io reaches for calls\n\n  const ENDPOINT = \"http://localhost:5000\"; //set authName\n\n  useEffect(() => {\n    //if there are loading timing issues, only load the higher order prop?\n    if (props.auth !== null) {\n      setUsername(props.auth.username);\n      setInfoname(props.auth.username);\n    }\n  }, [props.auth]); //socket.io connection\n\n  useEffect(() => {\n    //socket.io\n    socket = io(ENDPOINT, {\n      transports: ['websocket'],\n      withCredentials: true,\n      extraHeaders: {\n        \"my-header\": \"Tao\"\n      }\n    }); //Transports defines the type of connection method (ex.polling, websocket, handshake)\n\n    socket.emit(\"join\", {\n      username,\n      room\n    }, ({\n      error\n    }) => {\n      if (error) {\n        alert(error);\n      }\n\n      ;\n    });\n    return () => {\n      socket.off();\n    };\n  }, [ENDPOINT, username, room]); //messages listen. Sets messages/message state.\n\n  useEffect(() => {\n    socket.on(\"message\", message => {\n      setMessages([...messages, message]);\n      console.log(messages);\n    });\n  }, [messages, message]); //^^ added message so it will rerender. \n  //Couldn't find a way to re-render after redux state was updated so used useSelector, \n  //which is called everytime the selected redux state is updated. \n  //I think the reason inline conditonal statements don't work is becuase the state is updated after render, where as for nav, the state is not updated after render. \n\n  let userList = useSelector(state => state.user.users); //function for sending message\n\n  const sendMessage = event => {\n    event.preventDefault();\n\n    if (message) {\n      socket.emit(\"sendMessage\", message, () => setMessage(\"\"));\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"userlist\",\n      children: userList.map(user => {\n        return /*#__PURE__*/_jsxDEV(UserList, {\n          username: user.username,\n          onClick: e => {\n            setInfoname(user.username);\n            setRoom(username + \"&\" + user.username);\n          }\n        }, user._id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 100,\n          columnNumber: 28\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"chatbox\",\n      children: [/*#__PURE__*/_jsxDEV(InfoBar, {\n        name: infoName\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 113,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Messages, {\n        messages: messages,\n        name: username\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 115,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(Input, {\n        message: message,\n        setMessage: setMessage,\n        sendMessage: sendMessage\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 117,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 96,\n    columnNumber: 9\n  }, this);\n};\n\n_s(ChatComponent, \"voT0hpJjmo5V7El5AiCKCgF8TWM=\", false, function () {\n  return [useSelector];\n});\n\n_c = ChatComponent;\n\nconst mapStateToProps = state => {\n  return {\n    //auth is the user information (not the token in this case)\n    auth: state.auth.user,\n    //users is an array\n    users: state.user.users,\n    loading: state.user.loading\n  };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {// loadUser: () => dispatch(actionTypes_auth.loadUser()),\n  };\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ChatComponent); //Error \"cannot read map of underfined\": \"users\" prop read before \n//Timing should be ok, just that the component isnt rerendered when theres a change. \n\nvar _c;\n\n$RefreshReg$(_c, \"ChatComponent\");","map":{"version":3,"sources":["/Users/Tao.S/Desktop/WebDev/MA/frontend/src/Components/Chat/Chat/ChatComponent.tsx"],"names":["React","useState","useEffect","connect","useSelector","io","InfoBar","Input","Messages","UserList","socket","ChatComponent","props","username","setUsername","infoName","setInfoname","room","setRoom","message","setMessage","messages","setMessages","ENDPOINT","auth","transports","withCredentials","extraHeaders","emit","error","alert","off","on","console","log","userList","state","user","users","sendMessage","event","preventDefault","map","e","_id","mapStateToProps","loading","mapDispatchToProps","dispatch"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from \"react\";\nimport {connect, useSelector} from \"react-redux\";\nimport {io} from \"socket.io-client\";\n\n//Components\nimport InfoBar from \"../../Chat/InfoBar/InfoBar\";\nimport Input from \"../../Chat/Input/Input\";\nimport Messages from \"../../Chat/Messages/Messages\";\nimport UserList from \"../../Chat/UserList/UserList\";\n//Actions\n// import * as actionTypes_auth from \"../../../store/actions/auth_actions\";\n\nimport \"./Chat_style.css\";\n\nlet socket: any;\n\nconst ChatComponent = (props: any) => {\n\n    //username of other users. Changes based on selected user.\n    const [username, setUsername] = useState(\"\");\n    const [infoName, setInfoname] = useState(\"\");\n    //main user\n    // const [username2, setUsername2] = useState(\"Bob\");\n    //room name for each chat \n    const [room, setRoom] = useState(\"\");\n    const [message, setMessage] = useState(\"\");\n    const [messages, setMessages] = useState<String[]>([]);\n\n    //ENDPOINT is the backend server socket.io reaches for calls\n    const ENDPOINT = \"http://localhost:5000\";\n\n\n    //set authName\n    useEffect(() => {\n        \n        //if there are loading timing issues, only load the higher order prop?\n        if(props.auth  !== null){\n        setUsername(props.auth.username);\n        setInfoname(props.auth.username);\n        }\n        \n    }, [props.auth])\n\n    //socket.io connection\n    useEffect(() => {\n\n        //socket.io\n        socket = io(\n            ENDPOINT,  \n            { transports : ['websocket'], \n            withCredentials: true,\n            extraHeaders:{\n                \"my-header\": \"Tao\" \n            } }); //Transports defines the type of connection method (ex.polling, websocket, handshake)\n\n        \n        socket.emit(\"join\", {username, room}, ({error}: any) => {\n\n            if(error){\n                alert(error);\n            };\n        });\n\n        return () => {\n            socket.off();\n        }\n\n\n    }, [ENDPOINT, username, room])\n\n    //messages listen. Sets messages/message state.\n    useEffect(() => {\n        socket.on(\"message\", (message: any) => {\n            setMessages([...messages, message]);\n            console.log(messages);\n        })\n    }, [messages, message]);\n    //^^ added message so it will rerender. \n\n    //Couldn't find a way to re-render after redux state was updated so used useSelector, \n    //which is called everytime the selected redux state is updated. \n    //I think the reason inline conditonal statements don't work is becuase the state is updated after render, where as for nav, the state is not updated after render. \n    let userList = useSelector((state: any) => state.user.users)\n\n    \n    //function for sending message\n    const sendMessage = (event: any) => {\n        event.preventDefault();\n\n        if(message){\n            socket.emit(\"sendMessage\", message, () => setMessage(\"\"));\n        }\n    }\n\n    return(\n        <div className=\"container\">\n\n            <div className=\"userlist\">\n                {userList.map((user: any ) => {\n                    return <UserList key={user._id} username={user.username} onClick={(e: any) => {setInfoname(user.username); setRoom(username + \"&\" + user.username)}}/>\n                })}\n\n                {/* Doesn't recognize change of state after mount */}\n                {/* {props.users ?\n                    props.users.map((user: any ) => {\n                        return <UserList key={user._id} username={user.username} onClick={(e: any) => setUsername(user.username)}/>\n                    }):\n                    null\n                }         */}\n            </div>\n\n            <div className=\"chatbox\">\n                <InfoBar name={infoName}/>\n                {/* <Suspense fallback={<div>Loading</div>}> */}\n                <Messages messages={messages} name={username}></Messages>\n                {/* </Suspense> */}\n                <Input message={message} setMessage={setMessage} sendMessage={sendMessage}/>\n            </div>\n        </div>\n    )\n}\n\n\nconst mapStateToProps = (state: any) => {\n    return{\n        //auth is the user information (not the token in this case)\n        auth: state.auth.user,\n        //users is an array\n        users: state.user.users,\n        loading: state.user.loading, \n    }\n};\n\nconst mapDispatchToProps = (dispatch: any) => {\n    return{\n        // loadUser: () => dispatch(actionTypes_auth.loadUser()),\n    }\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(ChatComponent);\n\n//Error \"cannot read map of underfined\": \"users\" prop read before \n//Timing should be ok, just that the component isnt rerendered when theres a change. "]},"metadata":{},"sourceType":"module"}